\documentclass[a4paper,11pt]{article}%
    
\usepackage{fullpage}%
\usepackage[T1]{fontenc}%
\usepackage[utf8]{inputenc}%
\usepackage[french]{babel}% % Adjust the main language

\usepackage{graphicx}%
\usepackage{url}%
\usepackage{abstract}%
\usepackage{lipsum}
\usepackage{mathpazo}%
\usepackage{multicol}
\usepackage{listings}%

\usepackage{subcaption}

\parskip=0.5\baselineskip

\sloppy

\begin{document}

\title{Rapport de stage (mise en place de l'algorithme)}

\author{Clément Legrand-Lixon}

\date{}

\maketitle

Ce papier présente l'algorithme mis en œuvre dans le cadre du problème CVRP (Capacitated Vehicle Routing Problem), qui s'inspire en grande partie de l'article d'Arnold et Sörensen. 

\section*{Introduction}
Le Vehicle Routing Problem (VRP), consiste à relier un nombre $n$ de clients par des tournées, commençant et finissant toutes à un même point défini, le dépôt. Ce problème est NP-complet, et dispose de nombreuses applications dans le monde d'aujourd'hui (notamment gestion d'un réseau routier). D'autant plus que ce problème dispose de nombreuses variantes (ajout d'une contrainte de temps, plusieurs dépôts possibles...). L'une des variantes les plus connus consiste à prendre en compte pour chaque client sa demande, de sorte à ce que les tournées créées ne dépassent pas une certaine capacité définie à l'avance. On nomme ce problème CVRP (pour Capacitated Vehicle Routing Problem). 

Si de nombreuses heuristiques ont vu le jour pour résoudre ce problème, aucune d'entre elles ne parvient à trouver des solutions optimales pour toutes les instances de la littérature, malgré de très bons résultats dans la plupart des cas. Récemment \footnote{A simple, deterministic, and efficient knowledge-driven heuristic
for the vehicle routing problem (Florian Arnold, Kenneth Sorensen)}, une nouvelle heuristique efficace a vu le jour. L'objectif de mon stage est de s'inspirer de cette heuristique, et d'y intégrer de la connaissance pour rendre l'algorithme plus performant.

Ce rapport, commence par introduire les notations et opérateurs utilisés dans la suite.   
L'algorithme commence par initialiser une solution. Il applique ensuite des opérateurs locaux, tant que la condition d'arrêt n'est pas respectée. Lors de certaines itérations, il peut effectuer des opérations spéciales. A la sortie de la boucle, il effectue un raffinement de la solution.

\section{Présentations}

\subsection{Parcours et exploration des voisinages}
\label{voisinage}

Lorsqu'il s'agit de trouver une solution optimale à un problème, il est souvent intéressant d'explorer les voisinages d'une solution pour voir s'il n'y a pas mieux. Selon la méthode d'exploration employée, il peut être intéressant de parcourir le voisinage de différentes manières, pour ne pas toujours favoriser les mêmes voisins.

L'\underline{exploration} d'un voisinage de solutions peut être plus ou moins exhaustif selon la condition d'arrêt utilisée.
On distingue principalement, deux conditions d'arrêt lorsqu'il s'agit d'explorer des voisinages :

\begin{itemize}
\item First improvement (FI) : on parcourt le voisinage jusqu'à trouver un changement qui améliore la solution actuelle (on s'arrête donc à la première amélioration trouvée);
\item Best improvement (BI) : on parcourt tout le voisinage, et on applique le changement qui va le plus améliorer notre solution actuelle. \\
\end{itemize}

Pour explorer un voisinage, on peut le \underline{parcourir} de différentes manières de sorte à ne pas toujours favoriser les mêmes voisins. On considérera ici 3 parcours différents : 

\begin{itemize}
\item Dans l'ordre (O) : les voisins sont parcourus dans un ordre naturel (du premier au dernier);
\item Dans un semi-ordre (SO) : on commence le parcours là où on s'était arrêté au dernier parcours, on parcourt ensuite les voisins dans l'ordre;
\item Aléatoirement (RD) : on tire aléatoirement l'ordre dans lequel on va parcourir les voisins. \\
\end{itemize}

On peut remarquer que peut importe le parcours effectué, pour faire une exploration BI, il faudra passer par tous les voisins. On retiendra le tableau récapitulatif suivant:

\begin{center}
\begin{tabular}{|c|c|c|}
   \hline
     & BI & FI  \\
   \hline
   O & Oui & Oui \\
   \hline
   SO & Non & Oui \\
   \hline
   RD & Non & Oui  \\
   \hline
\end{tabular}
\end{center}


\subsection{Les constituants de l'algorithme}
Cette partie décrit l'ensemble des briques utilisées pour construire l'algorithme. Ces briques dépendent du problème étudiée (ici CVRP), mais sont indépendantes entre elles. De fait, il est possible de construire de nombreux algorithmes en les empilant de différents manières.

\subsubsection{Condition d'arrêt}

Lors de la recherche d'une solution optimale d'un problème, il est indispensable de s'intéresser à la condition d'arrêt de l'heuristique utilisée. En effet, on doit trouver un compromis entre temps de calcul et qualité de la solution recherchée. On ne peut jamais être totalement sûr que la solution obtenue est bien optimale, mais on ne peut pas non plus explorer l'intégralité des solutions. Les principales conditions d'arrêt rencontrées sont les suivantes :
\begin{itemize}
\item Un nombre d'itérations à ne pas dépasser;
\item Un certain temps d'itérations à ne pas dépasser (3 minutes dans l'article);
\item Un nombre d'itérations sans solutions améliorantes à ne pas dépasser (de l'ordre de $n^2$ dans mon algorithme). 
\end{itemize}

\subsubsection{Initialisation}
Cette brique consiste en la création d'une solution initiale, sur laquelle seront appliquées des modifications. 

Cette solution peut être créée de différentes manières:

\begin{itemize}
\item Elle peut être générée aléatoirement (Alea);
\item Elle peut être obtenue grâce à l'algorithme de Clarke \& Wright (CW), avec les paramètres ($\lambda,\mu,\nu$):
\begin{itemize}
\item Construire autant de tournées que de clients qui passent par le dépôt;
\item Pour toutes les paires de clients $(i,j)$ calculer le saving $s(i,j)$ via la formule : 
\begin{center}
$s(i,j) = c_{i0} + c_{0j} - \lambda c_{ij} + \mu \vert c_{i0} - c_{0j} \vert + \nu \frac{d_i + d_j}{\overline{d}}$
\end{center}
où $c_{ij}$ dénote la distance entre les clients $i$ et $j$ (le client 0 étant le dépôt), et $d_i$ dénote la demande du client $i$.
\item Considérer le couple $(i,j)$ possédant le saving le plus élevée;
\item Fusionner les tournées auxquelles appartiennent $i$ et $j$, si possible (tournées différentes, et $i$ et $j$ doivent être premier et dernier clients de leur tournée);
\item Mettre $s(i,j) = 0$
\item Recommencer tant que le saving maximal n'est pas négatif.
\end{itemize}
\item Elle peut être calculée grâce à l'intégration de connaissances (Learn) (objectif du stage).
\end{itemize}


\subsubsection{Pire arête et pénalisation}
A chaque tour de boucle, on calcule l'arête $(i,j)$ qui maximise la fonction suivante (donnée dans l'article):
\begin{center}
$b(i,j) = \frac{[\lambda_w w(i,j) + \lambda_c c(i,j)] [\frac{d(i,j)}{max_{k,l}d(k,l)}] ^ {\frac{\lambda_d}{2}}}{1+p(i,j)}$
\end{center}
où:
\begin{itemize}
\item $p(i,j)$ est la pénalisation de l'arête $(i,j)$ (nombre de fois où l'arête a maximisé $b$);
\item $w(i,j)$ est la largeur de l'arête $(i,j)$;
\item $c(i,j)$ est le coût de l'arête $(i,j)$ ($c(i,j) = c_{ij}(1 + \lambda p(i,j)$, avec $\lambda = 0.1$ dans l'article);
\item $d(i,j)$ est la profondeur de l'arête $(i,j)$ (max de $c_{0i}$ et $c_{0j}$);
\item les paramètres $\lambda_w,\lambda_c,\lambda_d$, prennent comme valeurs $0$ ou $1$, selon les caractéristiques que l'on veut considérer. Il y a ainsi 6 fonctions de pénalisation différentes, que l'on peut choisir au cours de l'exécution.

\end{itemize}

C'est autour de l'arête calculée ici que vont s'orienter les recherches des opérateurs locaux qui suivent.
 
\subsubsection{Ejection-Chain}

Cet opérateur va essayer de déplacer au plus $l$ clients sur des tournées plus adaptées. Dans l'article $l = 2$.

Cet opérateur s'exécute de la manière suivante :
\begin{itemize}
\item Déterminer une arête à éliminer; 
\item Considérer un des deux clients;
\item Regarder parmi les pp-voisins pour trouver une deuxième tournée;
\item Déplacer le client sur cette tournée (après le voisin trouvée);
\item Essayer de déplacer un client de cette tournée sur une autre tournée (en répétant les étapes précédentes);
\item Recommencer l'étape précédente $l$ fois; \\
\end{itemize} 

Pour les étapes $2$, $3$ et $5$, il est possible d'utiliser les méthodes de la section \ref{voisinage} pour explorer les voisinages.

\subsubsection{Cross-Exchange}

Cet opérateur essaie d'échanger deux séquences de clients successifs entre deux tournées. Il est possible de limiter le nombre de clients par séquence échangée (non implémenté). 

Cet opérateur s'exécute de la manière suivante :
\begin{itemize}
\item Choisir une arête $(c_1,c_2)$ à éliminer;
\item Trouver une autre tournée grâce aux pp-voisins de $c_1$; 
\item On note $c_4$ le voisin considéré, et $c_3$ le client précédent $c_4$ sur la nouvelle tournée;
\item On échange $c_1$ et $c_3$;
\item On essaie d'échanger deux autres clients entre les deux tournées. \\
\end{itemize}

Pour les étapes $2$ et $5$, il est possible d'utiliser les méthodes de la section \ref{voisinage} pour explorer les voisinages.

\subsubsection{Lin-Kernighan}

Utilisé en général pour résoudre le problème du voyageur de commerce (TSP). Il effectue une optimisation intra-tournée (c'est-à-dire que la tournée considérée est améliorée indépendamment des autres). Cela consiste en une réorganisation des clients sur la tournée. On choisit $k$ tel que \emph{LK} ne dépasse pas \emph{k-opt} au cours de son exécution. D'après l'article on peut prendre $k = 2$.

LK va donc s'exécuter de la manière suivante:
\begin{itemize}
\item On considère la tournée à améliorer;
\item On applique 2-opt sur la tournée (on échange deux clients sur la tournée);
\item Tant qu'on a des améliorations on applique 2-opt sur la tournée;
\item On renvoie la tournée améliorée. \\
\end{itemize}

Pour l'étape $2$, il est possible d'utiliser les méthodes de la section \ref{voisinage} pour explorer les voisinages.

\subsubsection{Raffinement}

Il est possible que la solution actuelle puisse être améliorée simplement. En effet, la solution considérée peut contenir une tournée qui ne contient qu'un client, et les solutions optimales ne contiennent en général pas ce genre de tournées.  

Une fonction \lstinline|reject| vient donc compléter l'opérateur EC, et sert à supprimer les routes qui n'ont qu'un client. Pour cela elle essaie d'intégrer le client sur une tournée proche (en parcourant les pp-voisins du client).

\subsection{Algorithmes mis en œuvre}
Nous présentons ici les algorithmes utilisés.
\subsubsection{Heuristique d'Arnold et Sörensen}

Cette heuristique se compose de la manière suivante :


\begin{center}
\begin{tabular}{|c|}

   \hline
   Initialisation$_{CW}$  \\
   \hline
   \hline
   Condition d'arrêt : 3 minutes depuis la dernière amélioration  \\
   \hline
   Compute worst edge \\
   \hline
   EC$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   CE$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   Itérations spéciales \\
   \hline
   \hline
   
\end{tabular}
\end{center}

\underline{Remarques}: La brique itérations spéciales, contient des opérations qui ne sont effectuées qu'après un certain nombre d'itérations sans améliorations. En effet, il peut souvent arriver que la solution actuelle soit bloquée sur un optimum local. Les auteurs ont choisi les opérations suivantes ($N$ désigne le nombre de clients):
\begin{itemize}
\item $N/10$ itérations sans améliorations $\rightarrow$ Optimisation global;
\item $20N$ itérations sans améliorations $\rightarrow$ Changement fonction de pénalisation;
\item $100N$ itérations sans améliorations $\rightarrow$ Reset des pénalités.
\end{itemize} 

Les auteurs calculent aussi à l'avance $30$ plus proches voisins pour chacun des clients.

\subsubsection{Algorithme utilisé}

L'algorithme (A$_d$) que j'utilise se compose de la manière suivante :

\begin{center}
\begin{tabular}{|c|}

   \hline
   Initialisation$_{CW}$  \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   \hline
   Condition d'arrêt : 1500 itérations depuis la dernière amélioration  \\
   \hline
   Compute worst edge \\
   \hline
   EC$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   CE$_{FI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   Itérations spéciales \\
   \hline
   \hline
   
\end{tabular}
\end{center}

\underline{Remarques}: Ici la brique itérations spéciales contient ($N$ désigne le nombre de clients):
\begin{itemize}
\item $N/2$ itérations sans améliorations $\rightarrow$ Retour à la dernière meilleure solution;
\item $5N/2$ itérations sans améliorations $\rightarrow$ Changement fonction de pénalisation et reset des pénalités;
\end{itemize} 


Un autre algorithme (A$_a$, où seul le bloc CE est modifié):
\begin{center}
\begin{tabular}{|c|}

   \hline
   Initialisation$_{CW}$  \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   \hline
   Condition d'arrêt : 1500 itérations depuis la dernière amélioration  \\
   \hline
   Compute worst edge \\
   \hline
   EC$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   CE$_{FI-RD}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   Itérations spéciales \\
   \hline
   \hline
   
\end{tabular}
\end{center}

Pour cet algorithme, j'effectue $25$ itérations en gardant la moyenne des coûts obtenus, ainsi que la solution qui a donné le meilleur coût.

 
\end{document}