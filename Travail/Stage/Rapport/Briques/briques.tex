\documentclass[a4paper,11pt]{article}%
    
\usepackage{fullpage}%
\usepackage[T1]{fontenc}%
\usepackage[utf8]{inputenc}%
\usepackage[french]{babel}% % Adjust the main language

\usepackage{graphicx}%
\usepackage{url}%
\usepackage{abstract}%
\usepackage{lipsum}
\usepackage{mathpazo}%
\usepackage{multicol}
\usepackage{listings}%
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{subcaption}

\parskip=0.5\baselineskip



\sloppy

\begin{document}

\title{Rapport de stage}

\author{Clément Legrand-Lixon}

\maketitle


\section*{Introduction}
Le Vehicle Routing Problem (VRP), consiste à relier un nombre $n$ de clients par des tournées, commençant et finissant toutes à un même point défini, le dépôt. Ce problème est NP-complet, et dispose de nombreuses applications dans le monde d'aujourd'hui (notamment gestion d'un réseau routier). D'autant plus que ce problème dispose de nombreuses variantes (ajout d'une contrainte de temps, plusieurs dépôts possibles...). L'une des variantes les plus connues consiste à prendre en compte pour chaque client sa demande, de sorte à ce que les tournées créées ne dépassent pas une certaine capacité définie à l'avance. On nomme ce problème Capacitated Vehicle Routing Problem (CVRP). 

Si de nombreuses heuristiques ont vu le jour pour résoudre ce problème, aucune d'entre elles ne parvient à trouver des solutions optimales pour toutes les instances de la littérature, malgré de très bons résultats dans la plupart des cas. Récemment~\cite{Sorensen_2017}, une nouvelle heuristique efficace a vu le jour. L'objectif de mon stage est de s'inspirer de cette heuristique, et d'y intégrer de la connaissance pour rendre l'algorithme plus performant.

Ce rapport commence par présenter le problème étudié, et introduit les notations et opérateurs utilisés dans la suite. Il décrit ensuite comment a été mise en place l'intégration de connaissances au sein de l'algorithme, puis présente les résultats obtenus.   

\section{Présentations}

\subsection{Description du problème}

\subsubsection{Vehicle Routing Problem (VRP)}

Le problème de tournées de véhicules, est un problème NP-complet, qui consiste à déterminer $k$ tournées pour desservir l'ensemble des $n$ clients présents.  Ces tournées doivent toutes passer par un dépôt fixé par l'instance. 
Ainsi les tournées créées doivent respecter les règles suivantes :
\begin{itemize}
\item Chaque client doit être desservi par une et une seule tournée;
\item Chaque tournée doit partir et s'arrêter au dépôt.
\end{itemize}
L'objectif est alors de minimiser la longueur du réseau (ensemble des tournées). La distance euclidienne est privilégiée pour la majorité des instances.
De nombreux algorithmes ont vu le jour pour tenter de résoudre ce problème, ainsi que les nombreuses variantes qui existent (ajout de contraintes de capacité, temps ou longueur sur les tournées, ces contraintes sont cumulables). 
C'est l'ajout de capacité aux tournées qui nous intéressera plus particulièrement.

\subsubsection{Capacitated VRP (CVRP)}

L'une des extensions les plus étudiées du VRP, est celle où on rajoute une contrainte de capacités sur les tournées, cette contrainte étant la même pour toutes les tournées. 
Dorénavant, chaque client a une certaine demande, mais la demande présente sur une tournée ne doit pas excéder la capacité disponible sur la tournée.
Les tournées doivent donc respecter la règle suivante, en plus de celles décrites à la section précédente :
\begin{itemize}
\item La demande totale sur chaque tournée ne doit pas excéder la capacité disponible.
\end{itemize}
Ce problème est beaucoup étudié car il a de nombreuses applications (comme le trafic routier), et peu de solutions optimales ont été trouvées pour des instances de plus de $500$ clients. 


\subsection{Parcours et exploration des voisinages}
\label{voisinage}

Lorsqu'il s'agit de trouver une solution optimale à un problème, il est souvent intéressant d'explorer les voisinages d'une solution pour voir s'il n'y a pas mieux. Selon la méthode d'exploration employée, il peut être intéressant de parcourir le voisinage de différentes manières, pour ne pas toujours favoriser les mêmes voisins.

L'\underline{exploration} d'un voisinage de solutions peut être plus ou moins exhaustif selon la condition d'arrêt utilisée.
On distingue principalement, deux conditions d'arrêt lorsqu'il s'agit d'explorer des voisinages :

\begin{itemize}
\item First improvement (\emph{FI}) : on parcourt le voisinage jusqu'à trouver un changement qui améliore la solution actuelle (on s'arrête donc à la première amélioration trouvée);
\item Best improvement (\emph{BI}) : on parcourt tout le voisinage, et on applique le changement qui va le plus améliorer notre solution actuelle. \\
\end{itemize}

Pour explorer un voisinage, on peut le \underline{parcourir} de différentes manières de sorte à ne pas toujours favoriser les mêmes voisins. On considérera ici 3 parcours différents : 

\begin{itemize}
\item Dans l'ordre (\emph{O}) : les voisins sont parcourus dans un ordre naturel (du premier au dernier);
\item Dans un semi-ordre (\emph{SO}) : on commence le parcours là où on s'était arrêté au dernier parcours, on parcourt ensuite les voisins dans l'ordre;
\item Aléatoirement (\emph{RD}) : on tire aléatoirement l'ordre dans lequel on va parcourir les voisins. \\
\end{itemize}

On peut remarquer que peu importe le parcours effectué, pour faire une exploration \emph{BI}, il faudra passer par tous les voisins. Pour qu'une exploration \emph{FI} soit efficace, il faut éviter un parcours \emph{O}, car dans ce cas on privilégie une certains voisinages qui seront choisis plus souvent. On retiendra le tableau récapitulatif suivant:

\begin{center}
\begin{tabular}{|c|c|c|}
   \hline
     & \emph{BI} & \emph{FI}  \\
   \hline
   \emph{O} & Oui & Non \\
   \hline
   \emph{SO} & Non & Oui \\
   \hline
   \emph{RD} & Non & Oui  \\
   \hline
\end{tabular}
\end{center}


\subsection{Les constituants de l'algorithme}
Cette partie décrit l'ensemble des briques utilisées pour construire l'algorithme. Ces briques dépendent du problème étudiée (ici CVRP), mais sont indépendantes entre elles. De fait, il est possible de construire de nombreux algorithmes en les empilant de différents manières.

\subsubsection{Condition d'arrêt}

Lors de la recherche d'une solution optimale d'un problème, il est indispensable de s'intéresser à la condition d'arrêt de l'heuristique utilisée. En effet, on doit trouver un compromis entre temps de calcul et qualité de la solution recherchée. On ne peut jamais être totalement sûr que la solution obtenue est bien optimale, mais on ne peut pas non plus explorer l'intégralité des solutions. Les principales conditions d'arrêt rencontrées sont les suivantes :
\begin{itemize}
\item Un nombre d'itérations à ne pas dépasser;
\item Un certain temps d'itérations sans solutions améliorantes à ne pas dépasser (3 minutes dans l'article~\cite{Sorensen_2017});
\item Un nombre d'itérations sans solutions améliorantes à ne pas dépasser (de l'ordre de $n^2$ dans mon algorithme). 
\end{itemize}

\subsubsection{Initialisation}
Cette brique consiste en la création d'une solution initiale, sur laquelle seront appliquées des modifications. 

Cette solution peut être créée de différentes manières:

\begin{itemize}
\item Elle peut être générée aléatoirement (Alea);
\item Elle peut être obtenue grâce à l'algorithme de Clarke \& Wright (CW), avec les paramètres ($\lambda,\mu,\nu$)~\cite{Altinel_2005}: 
\begin{itemize}
\item Construire autant de tournées que de clients qui passent par le dépôt;
\item Pour toutes les paires de clients $(i,j)$ calculer le saving $s(i,j)$ via la formule : 
\begin{center}
$s(i,j) = c_{i0} + c_{0j} - \lambda c_{ij} + \mu \vert c_{i0} - c_{0j} \vert + \nu \frac{d_i + d_j}{\overline{d}}$
\end{center}
où $c_{ij}$ dénote la distance entre les clients $i$ et $j$ (le client 0 étant le dépôt), et $d_i$ dénote la demande du client $i$.
\item Considérer le couple $(i,j)$ possédant le saving le plus élevée;
\item Fusionner les tournées auxquelles appartiennent $i$ et $j$, si possible (tournées différentes, et $i$ et $j$ doivent être premier et dernier clients de leur tournée);
\item Mettre $s(i,j) = 0$
\item Recommencer tant que le saving maximal n'est pas négatif.
\end{itemize}
\item Elle peut être calculée grâce à l'intégration de connaissances (Learn) (objectif du stage).
\end{itemize}


\subsubsection{Pire arête et pénalisation}
A chaque tour de boucle, on calcule l'arête $(i,j)$ qui maximise la fonction suivante (donnée dans l'article):
\begin{center}
$b(i,j) = \frac{[\lambda_w w(i,j) + \lambda_c c(i,j)] [\frac{d(i,j)}{max_{k,l}d(k,l)}] ^ {\frac{\lambda_d}{2}}}{1+p(i,j)}$
\end{center}
où:
\begin{itemize}
\item $p(i,j)$ est la pénalisation de l'arête $(i,j)$ (nombre de fois où l'arête a maximisé $b$);
\item $w(i,j)$ est la largeur de l'arête $(i,j)$;
\item $c(i,j)$ est le coût de l'arête $(i,j)$ ($c(i,j) = c_{ij}(1 + \lambda p(i,j)$, avec $\lambda = 0.1$ dans l'article);
\item $d(i,j)$ est la profondeur de l'arête $(i,j)$ (max de $c_{0i}$ et $c_{0j}$);
\item les paramètres $\lambda_w,\lambda_c,\lambda_d$, prennent comme valeurs $0$ ou $1$, selon les caractéristiques que l'on veut considérer. Il y a ainsi 6 fonctions de pénalisation différentes, que l'on peut choisir au cours de l'exécution.

\end{itemize}

C'est autour de l'arête calculée ici que vont s'orienter les recherches des opérateurs locaux qui suivent.
 
\subsubsection{Ejection-Chain}

Cet opérateur va essayer de déplacer au plus $l$ clients sur des tournées plus adaptées. Dans l'article~\cite{Sorensen_2017} $l = 3$.
L'algorithme~\ref{algo:EC} décrit le fonctionnement de cet opérateur.

\begin{algorithm}
\DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
\KwIn{Une arête $(a,b)$, la liste des plus proches voisins des clients $voisins$, un entier $l$, la solution actuelle $sol$}
\KwOut{Une nouvelle solution au moins aussi bonne que $sol$}
$initialCost \gets cost(sol)$\;
$possibleSol \gets sol$\;
$cand \gets choose(a,b)$\;
$nextRoute \gets findNextRoute(cand,voisins,possibleSol)$\;
$possibleSol \gets $ déplacer $cand$ après son voisin sur $nextRoute$\;
\For{$i \gets 1$ \textbf{to} $l-1$} {
  $cand \gets $un client de nextRoute différent de celui ajouté\;
  $nextRoute \gets findNextRoute(cand,voisins,possibleSol)$\;
  $possibleSol \gets$ déplacer $cand$ après son voisin sur $nextRoute$\;
}
\If {$cost < cost(sol)$} {
	\Return{$sol$}\;
}
\Return{$possibleSol$}\;
\caption{{\sc Ejection-Chain} applique l'opérateur ejection-chain}
\label{algo:EC}
\end{algorithm}

Aux lignes $3, 4, 7$ et $8$ de l'algorithme~\ref{algo:EC}, il est possible d'utiliser les méthodes de la section~\ref{voisinage} pour explorer les voisinages.

\subsubsection{Cross-Exchange}

Cet opérateur essaie d'échanger deux séquences de clients successifs entre deux tournées. Il est possible de limiter le nombre de clients par séquence échangée.
L'algorithme~\ref{algo:CE} présente l'exécution de l'opérateur.

\begin{algorithm}
\DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
\KwIn{Une arête $(c_1,c_2)$, la liste des plus proches voisins des clients $voisins$, la solution actuelle $sol$}
\KwOut{Une nouvelle solution au moins aussi bonne que $sol$}
$initialCost \gets cost(sol)$\;
$possibleSol \gets sol$\;
$nextRoute \gets findNextRoute(c_1,voisins,possibleSol)$\;
Considérer l'arête $(c_3,c_4)$ de $nextRoute$, où $c_4$ est le proche voisin de $c_1$ utilisé\;
$possibleSol \gets exchange(c_1,c_3,possibleSol)$\;
Choisir 2 clients $c_5$ et $c_6$ qui n'appartiennent pas à la même tournée\;
$possibleSol \gets exchange(c_5,c_6,possibleSol)$\;
\If {$cost < cost(sol)$} {
	\Return{$sol$}\;
}
\Return{$possibleSol$}\;
\caption{{\sc Cross-Exchange} applique l'opérateur cross-exchange}
\label{algo:CE}
\end{algorithm}

A la ligne $6$ de l'algorithme~\ref{algo:CE}, il est possible d'utiliser les méthodes de la section \ref{voisinage} pour explorer les voisinages, et choisir les clients à échanger.

\subsubsection{Lin-Kernighan}

L'heuristique Lin-Kernighan est utilisé en général pour résoudre le problème du voyageur de commerce (TSP). Il effectue une optimisation intra-tournée (c'est-à-dire que la tournée considérée est améliorée indépendamment des autres). Cela consiste en une réorganisation des clients sur la tournée. On choisit $k$ tel que \emph{LK} ne dépasse pas \emph{k-opt} au cours de son exécution. On appelle \emph{k-opt}, l'opération qui consiste à échanger $k$ clients différents sur la tournée. D'après l'article~\cite{Sorensen_2017}, on peut prendre $k = 2$.
L'algorithme~\ref{algo:LK} décrit l'exécution de l'opérateur.

\begin{algorithm}
\DontPrintSemicolon % Some LaTeX compilers require you to use \dontprintsemicolon instead
\KwIn{Une tournée $r$ à améliorer}
\KwOut{Une permutation de $r$ ayant un meilleur coût que $r$}
$r_{next} \gets 2$-$opt(r) $\;
\While{$ r_{next} \neq r$} {
  $r \gets r_{next}$\;
  $r_{next} \gets 2$-$opt(r)$\;
}
\Return{$r$}\;
\caption{{\sc Lin-Kernighan} applique l'opérateur Lin-Kernighan}
\label{algo:LK}
\end{algorithm}

Lorsqu'il s'agit d'appliquer \emph{2-opt}, il est possible d'utiliser les méthodes de la section \ref{voisinage} pour explorer les voisinages.

\subsubsection{Raffinement}

Il est possible que la solution actuelle puisse être améliorée simplement. En effet, la solution considérée peut contenir une tournée qui ne contient qu'un client, et les solutions optimales ne contiennent en général pas ce genre de tournées.  

Une fonction \lstinline|reject| vient donc compléter l'opérateur \emph{EC}, et sert à supprimer les routes qui n'ont qu'un client. Pour cela elle essaie d'intégrer le client sur une tournée proche (en parcourant les plus proches voisins du client).

\subsection{Algorithmes mis en œuvre}
Nous présentons ici les algorithmes utilisés.
\subsubsection{Heuristique d'Arnold et Sörensen}

Cette heuristique se compose de la manière suivante :


\begin{center}
\begin{tabular}{|c|}

   \hline
   Initialisation$_{CW}$  \\
   \hline
   \hline
   Condition d'arrêt : 3 minutes depuis la dernière amélioration  \\
   \hline
   Compute worst edge \\
   \hline
   EC$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   CE$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   Itérations spéciales \\
   \hline
   \hline
   
\end{tabular}
\end{center}

\underline{Remarques}: La brique itérations spéciales, contient des opérations qui ne sont effectuées qu'après un certain nombre d'itérations sans améliorations. En effet, il peut souvent arriver que la solution actuelle soit bloquée sur un optimum local. Les auteurs ont choisi les opérations suivantes ($N$ désigne le nombre de clients):
\begin{itemize}
\item $N/10$ itérations sans améliorations $\rightarrow$ Optimisation global;
\item $20N$ itérations sans améliorations $\rightarrow$ Changement fonction de pénalisation;
\item $100N$ itérations sans améliorations $\rightarrow$ Reset des pénalités.
\end{itemize} 

Les auteurs calculent aussi à l'avance $30$ plus proches voisins pour chacun des clients.

\subsubsection{Algorithme utilisé}

L'algorithme (A$_d$) que j'utilise se compose de la manière suivante :

\begin{center}
\begin{tabular}{|c|}

   \hline
   Initialisation$_{CW}$  \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   \hline
   Condition d'arrêt : 1500 itérations depuis la dernière amélioration  \\
   \hline
   Compute worst edge \\
   \hline
   EC$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   CE$_{FI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   Itérations spéciales \\
   \hline
   \hline
   
\end{tabular}
\end{center}

\underline{Remarques}: Ici la brique itérations spéciales contient ($N$ désigne le nombre de clients):
\begin{itemize}
\item $N/2$ itérations sans améliorations $\rightarrow$ Retour à la dernière meilleure solution;
\item $5N/2$ itérations sans améliorations $\rightarrow$ Changement fonction de pénalisation et reset des pénalités;
\end{itemize} 


Un autre algorithme (A$_a$, où seul le bloc CE est modifié):
\begin{center}
\begin{tabular}{|c|}

   \hline
   Initialisation$_{CW}$  \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   \hline
   Condition d'arrêt : 1500 itérations depuis la dernière amélioration  \\
   \hline
   Compute worst edge \\
   \hline
   EC$_{BI-O}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   CE$_{FI-RD}$ \\
   \hline
   LK$_{BI-O}$ \\
   \hline
   Itérations spéciales \\
   \hline
   \hline
   
\end{tabular}
\end{center}

Pour cet algorithme, j'effectue $25$ itérations en gardant la moyenne des coûts obtenus, ainsi que la solution qui a donné le meilleur coût.

\section{Intégration de connaissances}


\bibliographystyle{plain}
\bibliography{biblio}

\end{document}